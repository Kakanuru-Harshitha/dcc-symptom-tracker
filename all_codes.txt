--- lib/models/log_entry.dart ---
// lib/models/log_entry.dart
import 'symptom.dart';
class LogEntry {
  int? id;
  DateTime date;
  List<Symptom> symptoms;
  String note;
  bool medsMorning;
  bool medsAfternoon;
  LogEntry({
    this.id,
    required this.date,
    required this.symptoms,
    required this.note,
    required this.medsMorning,
    required this.medsAfternoon,
  });
  Map<String,dynamic> toMap() => {
        'id': id,
        'date': date.millisecondsSinceEpoch,
        'symptoms': symptoms.map((s)=>s.toMap()).toList(),
        'note': note,
        'medsMorning': medsMorning?1:0,
        'medsAfternoon': medsAfternoon?1:0,
      };
  factory LogEntry.fromMap(Map<String,dynamic> m) => LogEntry(
        id: m['id'],
        date: DateTime.fromMillisecondsSinceEpoch(m['date']),
        symptoms: (m['symptoms'] as List)
            .map((x)=>Symptom.fromMap(Map<String,dynamic>.from(x)))
            .toList(),
        note: m['note'],
        medsMorning: m['medsMorning']==1,
        medsAfternoon: m['medsAfternoon']==1,
      );
}


--- lib/models/medication.dart ---
// lib/models/medication.dart
class Medication {
  int? id;
  String name;
  String dosage;
  int timesPerDay;
  bool takenToday;
  Medication({
    this.id,
    required this.name,
    required this.dosage,
    required this.timesPerDay,
    this.takenToday = false,
  });
  Map<String,dynamic> toMap() => {
        'id': id,
        'name': name,
        'dosage': dosage,
        'timesPerDay': timesPerDay,
        'takenToday': takenToday ? 1 : 0,
      };
  factory Medication.fromMap(Map<String,dynamic> m) => Medication(
        id: m['id'],
        name: m['name'],
        dosage: m['dosage'],
        timesPerDay: m['timesPerDay'],
        takenToday: m['takenToday']==1,
      );
}


--- lib/models/symptom.dart ---
// lib/models/symptom.dart
class Symptom {
  final String type;
  final String location;
  final int severity;
  Symptom({
    required this.type,
    required this.location,
    required this.severity,
  });
  Map<String,dynamic> toMap() => {
        'type': type,
        'location': location,
        'severity': severity,
      };
  factory Symptom.fromMap(Map<String,dynamic> m) => Symptom(
        type: m['type'],
        location: m['location'],
        severity: m['severity'],
      );
}


--- lib/models/trend_point.dart ---
// lib/models/trend_point.dart
class TrendPoint {
  final DateTime date;
  final double value;
  TrendPoint({required this.date, required this.value});
}


--- lib/providers/log_provider.dart ---
// lib/providers/log_provider.dart
import 'package:flutter/material.dart';
import '../models/log_entry.dart';

class LogProvider extends ChangeNotifier {
  final List<LogEntry> _logs = [];

  /// Read‐only view of the logs
  List<LogEntry> get logs => List.unmodifiable(_logs);

  /// Called on startup (you can hook up persistence here later)
  void load() {
    // For now, nothing to load.
    // Later you could read from disk / database here.
  }

  /// Add a new log entry
  void add(LogEntry entry) {
    _logs.add(entry);
    notifyListeners();
  }

  /// Remove an existing entry
  void remove(LogEntry entry) {
    _logs.remove(entry);
    notifyListeners();
  }
}


--- lib/providers/med_provider.dart ---
// lib/providers/med_provider.dart
import 'package:flutter/foundation.dart';
import 'package:sqflite/sqflite.dart';
import '../models/medication.dart';
import '../services/database_service.dart';

class MedProvider extends ChangeNotifier {
  final Database _db = DatabaseService().db;
  List<Medication> meds = [];

  Future<void> load() async {
    final rows = await _db.query('meds');
    meds = rows.map((r) => Medication.fromMap(r)).toList();
    notifyListeners();
  }

  Future<void> addOrUpdate(Medication m) async {
    if (m.id == null) {
      m.id = await _db.insert('meds', m.toMap());
    } else {
      await _db.update('meds', m.toMap(),
          where: 'id=?', whereArgs: [m.id]);
    }
    await load();
  }

  Future<void> toggleTaken(Medication m) async {
    m.takenToday = !m.takenToday;
    await addOrUpdate(m);
  }
}


--- lib/providers/settings_provider.dart ---
// lib/providers/settings_provider.dart
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';

class SettingsProvider extends ChangeNotifier {
  bool darkMode = false;

  SettingsProvider() {
    _load();
  }

  Future<void> _load() async {
    final p = await SharedPreferences.getInstance();
    darkMode = p.getBool('darkMode') ?? false;
    notifyListeners();
  }

  Future<void> setDark(bool v) async {
    darkMode = v;
    final p = await SharedPreferences.getInstance();
    await p.setBool('darkMode', v);
    notifyListeners();
  }
}


--- lib/screens/calendar_screen.dart ---
// lib/screens/calendar_screen.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../providers/log_provider.dart';
import 'log_symptom_screen.dart';
import '../models/log_entry.dart';

class CalendarScreen extends StatefulWidget {
  const CalendarScreen({super.key});
  @override
  State<CalendarScreen> createState() => _CalendarScreenState();
}

class _CalendarScreenState extends State<CalendarScreen> {
  DateTime _month = DateTime.now();
  DateTime _sel = DateTime.now();

  void _prev() =>
      setState(() => _month = DateTime(_month.year, _month.month - 1, 1));
  void _next() =>
      setState(() => _month = DateTime(_month.year, _month.month + 1, 1));

  List<DateTime> get _days {
    final cnt = DateUtils.getDaysInMonth(_month.year, _month.month);
    return [
      for (int i = 1; i <= cnt; i++) DateTime(_month.year, _month.month, i),
    ];
  }

  @override
  Widget build(BuildContext context) {
    final prov = context.watch<LogProvider>();
    final dayLogs =
        prov.logs
            .where(
              (l) =>
                  l.date.year == _sel.year &&
                  l.date.month == _sel.month &&
                  l.date.day == _sel.day,
            )
            .toList();

    return Scaffold(
      floatingActionButton: FloatingActionButton(
        child: const Icon(Icons.add),
        onPressed:
            () => Navigator.push(
              context,
              MaterialPageRoute(
                builder: (_) => const LogSymptomScreen(),
                settings: RouteSettings(arguments: _sel),
              ),
            ),
      ),
      body: Column(
        children: [
          // Month nav
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              IconButton(
                onPressed: _prev,
                icon: const Icon(Icons.chevron_left),
              ),
              Text(
                DateFormat('MMMM yyyy').format(_month),
                style: Theme.of(context).textTheme.titleLarge,
              ),
              IconButton(
                onPressed: _next,
                icon: const Icon(Icons.chevron_right),
              ),
            ],
          ),

          // Day strip
          SizedBox(
            height: 80,
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              itemCount: _days.length,
              itemBuilder: (_, i) {
                final d = _days[i];
                final sel =
                    d.year == _sel.year &&
                    d.month == _sel.month &&
                    d.day == _sel.day;
                final has = prov.logs.any(
                  (l) =>
                      l.date.year == d.year &&
                      l.date.month == d.month &&
                      l.date.day == d.day,
                );
                return GestureDetector(
                  onTap: () => setState(() => _sel = d),
                  child: Container(
                    width: 60,
                    margin: const EdgeInsets.symmetric(
                      horizontal: 4,
                      vertical: 8,
                    ),
                    decoration: BoxDecoration(
                      color: sel ? Theme.of(context).colorScheme.primary : null,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          DateFormat('E').format(d),
                          style: TextStyle(color: sel ? Colors.white : null),
                        ),
                        Text(
                          '${d.day}',
                          style: TextStyle(
                            fontSize: 18,
                            color: sel ? Colors.white : null,
                          ),
                        ),
                        if (has)
                          Icon(
                            Icons.circle,
                            size: 6,
                            color:
                                sel
                                    ? Colors.white
                                    : Theme.of(context).colorScheme.secondary,
                          ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),

          const Divider(),

          // Logs list
          Expanded(
            child: ListView.builder(
              itemCount: dayLogs.length,
              itemBuilder: (_, i) {
                final entry = dayLogs[i];
                return Dismissible(
                  key: ValueKey(entry),
                  background: Container(
                    color: Colors.red,
                    alignment: Alignment.centerRight,
                    padding: const EdgeInsets.only(right: 20),
                    child: const Icon(Icons.delete, color: Colors.white),
                  ),
                  onDismissed: (_) => prov.remove(entry),
                  child: Card(
                    margin: const EdgeInsets.all(8),
                    child: ListTile(
                      title: Text(entry.symptoms.map((s) => s.type).join(', ')),
                      subtitle: Text(entry.note),
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}


--- lib/screens/home_screen.dart ---
// lib/screens/home_screen.dart
import 'package:flutter/material.dart';
import 'calendar_screen.dart';
import 'trends_screen.dart';
import 'med_list_screen.dart';
import 'report_screen.dart';
import 'settings_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});
  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  int _idx = 0;

  static const _titles = [
    'Calendar',
    'Trends',
    'Medications',
    'Report',
    'Settings',
  ];

  static const _screens = [
    CalendarScreen(),
    TrendsScreen(),
    MedListScreen(),
    ReportScreen(),
    SettingsScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(_titles[_idx])),
      body: _screens[_idx],
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _idx,
        onTap: (i) => setState(() => _idx = i),
        items: const [
          BottomNavigationBarItem(
              icon: Icon(Icons.calendar_month), label: 'Calendar'),
          BottomNavigationBarItem(icon: Icon(Icons.show_chart), label: 'Trends'),
          BottomNavigationBarItem(
              icon: Icon(Icons.medical_services), label: 'Meds'),
          BottomNavigationBarItem(
              icon: Icon(Icons.picture_as_pdf), label: 'Report'),
          BottomNavigationBarItem(icon: Icon(Icons.settings), label: 'Settings'),
        ],
      ),
      // ← No more FAB here; CalendarScreen will show its own
    );
  }
}


--- lib/screens/log_symptom_screen.dart ---
// lib/screens/log_symptom_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../utils/constants.dart';
import '../widgets/body_map.dart';
import '../widgets/severity_slider.dart';
import '../models/symptom.dart';
import '../models/log_entry.dart';
import '../providers/log_provider.dart';

class LogSymptomScreen extends StatefulWidget {
  const LogSymptomScreen({super.key});
  @override
  State<LogSymptomScreen> createState() => _LogSymptomScreenState();
}

class _LogSymptomScreenState extends State<LogSymptomScreen> {
  // The date for this entry (can be passed in via arguments)
  DateTime _date = DateTime.now();

  // Controllers
  final _noteC = TextEditingController();
  final _customC = TextEditingController();

  // Symptom type & custom list
  late List<String> _allTypes;
  String _type = '';

  // For types requiring a body location
  static const _needsLoc = {'Pain', 'Fatigue'};
  Set<String> _locs = {};

  // Severity slider
  int _sev = 5;

  // Medication checkboxes
  bool _morn = false, _aft = false;

  @override
  void initState() {
    super.initState();
    _allTypes = List.from(kSymptomTypes);
    _type = _allTypes.first;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // If a DateTime was passed via Navigator arguments, use it
    final argDate = ModalRoute.of(context)?.settings.arguments;
    if (argDate is DateTime) {
      setState(() {
        _date = argDate;
      });
    }
  }

  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _date,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked != null) {
      setState(() => _date = picked);
    }
  }

  void _showCustomDialog() {
    showDialog(
      context: context,
      builder:
          (_) => AlertDialog(
            title: const Text('Add custom symptom'),
            content: TextField(
              controller: _customC,
              decoration: const InputDecoration(labelText: 'Symptom name'),
            ),
            actions: [
              TextButton(
                onPressed: () {
                  final txt = _customC.text.trim();
                  if (txt.isNotEmpty && !_allTypes.contains(txt)) {
                    setState(() {
                      _allTypes.add(txt);
                      _type = txt;
                      if (!_needsLoc.contains(_type)) _locs.clear();
                    });
                  }
                  _customC.clear();
                  Navigator.pop(context);
                },
                child: const Text('Add'),
              ),
            ],
          ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Log Symptom')),
      body: Padding(
        padding: const EdgeInsets.all(12),
        child: ListView(
          children: [
            // Date picker row
            Row(
              children: [
                const Icon(Icons.calendar_month),
                const SizedBox(width: 8),
                TextButton(
                  onPressed: _pickDate,
                  child: Text(
                    '${_date.month}/${_date.day}/${_date.year}',
                    style: const TextStyle(fontSize: 16),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),

            // Symptom type + add custom
            Row(
              children: [
                Expanded(
                  child: DropdownButtonFormField<String>(
                    decoration: const InputDecoration(labelText: 'Type'),
                    value: _type,
                    items:
                        _allTypes
                            .map(
                              (t) => DropdownMenuItem(value: t, child: Text(t)),
                            )
                            .toList(),
                    onChanged:
                        (v) => setState(() {
                          _type = v!;
                          if (!_needsLoc.contains(_type)) _locs.clear();
                        }),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.add_circle_outline),
                  onPressed: _showCustomDialog,
                  tooltip: 'Add custom symptom',
                ),
              ],
            ),
            const SizedBox(height: 16),

            // Location picker (only for certain types)
            if (_needsLoc.contains(_type)) ...[
              const Text('Locations'),
              const SizedBox(height: 8),
              BodyMap(
                selected: _locs,
                onChanged: (s) => setState(() => _locs = s),
              ),
              const SizedBox(height: 16),
            ],

            // Severity slider
            SeveritySlider(
              value: _sev,
              onChanged: (v) => setState(() => _sev = v),
            ),
            const SizedBox(height: 16),

            // Note field
            TextField(
              controller: _noteC,
              decoration: const InputDecoration(labelText: 'Note'),
              maxLines: 3,
            ),
            const SizedBox(height: 16),

            // Medication checkboxes
            CheckboxListTile(
              title: const Text('Morning meds taken'),
              value: _morn,
              onChanged: (v) => setState(() => _morn = v!),
            ),
            CheckboxListTile(
              title: const Text('Afternoon meds taken'),
              value: _aft,
              onChanged: (v) => setState(() => _aft = v!),
            ),
            const SizedBox(height: 24),

            // Save button
            ElevatedButton(
              onPressed: () {
                // Build symptom list (with or without locations)
                final syms =
                    _needsLoc.contains(_type) && _locs.isNotEmpty
                        ? _locs
                            .map(
                              (loc) => Symptom(
                                type: _type,
                                location: loc,
                                severity: _sev,
                              ),
                            )
                            .toList()
                        : [Symptom(type: _type, location: '', severity: _sev)];

                final entry = LogEntry(
                  date: DateTime(
                    _date.year,
                    _date.month,
                    _date.day,
                  ), // chosen date
                  symptoms: syms,
                  note: _noteC.text.trim(),
                  medsMorning: _morn,
                  medsAfternoon: _aft,
                );
                context.read<LogProvider>().add(entry);
                Navigator.pop(context);
              },
              child: const Text('Save Entry'),
            ),
          ],
        ),
      ),
    );
  }
}


--- lib/screens/med_edit_screen.dart ---
// lib/screens/med_edit_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/medication.dart';
import '../providers/med_provider.dart';

class MedEditScreen extends StatefulWidget {
  final Medication? med;
  const MedEditScreen({this.med,super.key});
  @override
  State<MedEditScreen> createState() => _MedEditScreenState();
}

class _MedEditScreenState extends State<MedEditScreen> {
  final _nameC=TextEditingController();
  final _dosC=TextEditingController();
  int _times=1;

  @override
  void initState(){
    super.initState();
    if(widget.med!=null){
      _nameC.text = widget.med!.name;
      _dosC.text = widget.med!.dosage;
      _times = widget.med!.timesPerDay;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
          title: Text(widget.med==null?'Add Medication':'Edit Medication')),
      body: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          children:[
            TextField(
              controller:_nameC,
              decoration: const InputDecoration(labelText:'Name'),
            ),
            const SizedBox(height:8),
            TextField(
              controller:_dosC,
              decoration: const InputDecoration(labelText:'Dosage'),
            ),
            Row(
              children:[
                const Text('Times/day'),
                IconButton(
                  icon: const Icon(Icons.remove),
                  onPressed: _times>1 ? ()=>setState(()=>_times--) : null,
                ),
                Text('$_times'),
                IconButton(
                  icon: const Icon(Icons.add),
                  onPressed: ()=>setState(()=>_times++),
                ),
              ],
            ),
            const Spacer(),
            ElevatedButton(
              child: const Text('Save'),
              onPressed:(){
                final m = widget.med ?? Medication(
                  name:'',dosage:'',timesPerDay:1);
                m.name = _nameC.text;
                m.dosage= _dosC.text;
                m.timesPerDay = _times;
                context.read<MedProvider>().addOrUpdate(m);
                Navigator.pop(context);
              },
            ),
          ],
        ),
      ),
    );
  }
}


--- lib/screens/med_list_screen.dart ---
// lib/screens/med_list_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/med_provider.dart';
import '../widgets/med_list_item.dart';
import 'med_edit_screen.dart';

class MedListScreen extends StatelessWidget {
  const MedListScreen({super.key});
  @override
  Widget build(BuildContext context) {
    final meds = context.watch<MedProvider>().meds;
    return Scaffold(
      body: ListView.builder(
        itemCount: meds.length,
        itemBuilder:(_,i)=>MedListItem(
          med:meds[i],
          onTap:(){
            Navigator.push(context, MaterialPageRoute(
              builder:(_)=>MedEditScreen(med:meds[i]),
            ));
          },
        ),
      ),
      floatingActionButton: FloatingActionButton(
        child: const Icon(Icons.add),
        onPressed:()=>
          Navigator.pushNamed(context,'/med_edit'),
      ),
    );
  }
}


--- lib/screens/report_screen.dart ---
// lib/screens/report_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:share_plus/share_plus.dart';
import '../providers/log_provider.dart';
import '../providers/med_provider.dart';
import '../services/report_service.dart';

class ReportScreen extends StatefulWidget {
  const ReportScreen({super.key});
  @override
  State<ReportScreen> createState() => _ReportScreenState();
}

class _ReportScreenState extends State<ReportScreen> {
  DateTime _from = DateTime.now().subtract(const Duration(days: 7));
  DateTime _to = DateTime.now();
  final _qC = TextEditingController();

  Future<void> _pickFrom() async {
    final dt = await showDatePicker(
      context: context,
      initialDate: _from,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (dt != null) setState(() => _from = dt);
  }

  Future<void> _pickTo() async {
    final dt = await showDatePicker(
      context: context,
      initialDate: _to,
      firstDate: _from,
      lastDate: DateTime.now(),
    );
    if (dt != null) setState(() => _to = dt);
  }

  @override
  Widget build(BuildContext context) {
    final logs = context.read<LogProvider>().logs;
    final meds = context.read<MedProvider>().meds;

    return Scaffold(
      appBar: AppBar(title: const Text('Generate Report')),
      body: ListView(
        padding: const EdgeInsets.all(12),
        children: [
          Row(
            children: [
              Expanded(
                child: TextButton(
                  onPressed: _pickFrom,
                  child: Text('From: ${_from.toLocal()}'.split(' ')[0]),
                ),
              ),
              Expanded(
                child: TextButton(
                  onPressed: _pickTo,
                  child: Text('To:   ${_to.toLocal()}'.split(' ')[0]),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          TextField(
            controller: _qC,
            decoration: const InputDecoration(labelText: 'Questions for Doctor'),
            maxLines: 2,
          ),
          const SizedBox(height: 16),
          ElevatedButton(
            child: const Text('Build & Share PDF'),
            onPressed: () async {
              final file = await ReportService()
                  .generate(logs, meds, _from, _to, _qC.text);
              await Share.shareXFiles([XFile(file.path)],
                  text: 'My Symptom Report');
            },
          ),
        ],
      ),
    );
  }
}


--- lib/screens/settings_screen.dart ---
// lib/screens/settings_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/settings_provider.dart';
import '../services/notification_service.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});
  @override
  Widget build(BuildContext context) {
    final s = context.watch<SettingsProvider>();
    return ListView(
      padding: const EdgeInsets.all(12),
      children: [
        SwitchListTile(
          title: const Text('Dark mode'),
          value: s.darkMode,
          onChanged: (v) => s.setDark(v),
        ),
        const SizedBox(height:12),
        ListTile(
          title: const Text('Daily reminder at 09:00'),
          onTap: () => NotificationService()
              .scheduleDaily(const TimeOfDay(hour:9,minute:0)),
        ),
      ],
    );
  }
}


--- lib/screens/trends_screen.dart ---
// lib/screens/trends_screen.dart
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/log_provider.dart';
import '../services/trend_service.dart';
import '../widgets/trend_chart.dart';
import '../models/trend_point.dart';
import '../utils/constants.dart';
import 'report_screen.dart';

class TrendsScreen extends StatefulWidget {
  const TrendsScreen({super.key});
  @override
  State<TrendsScreen> createState() => _TrendsScreenState();
}

class _TrendsScreenState extends State<TrendsScreen> {
  // Our selected date range
  DateTime _from = DateTime.now().subtract(const Duration(days: 6));
  DateTime _to = DateTime.now();

  // Which symptom types are shown
  late Map<String, bool> _show;

  // Computed insight text
  String _insight = '';

  @override
  void initState() {
    super.initState();
    // Start with all types visible
    _show = {for (var t in kSymptomTypes) t: true};
  }

  Future<void> _pickDate(bool isFrom) async {
    final initial = isFrom ? _from : _to;
    final picked = await showDatePicker(
      context: context,
      initialDate: initial,
      firstDate: DateTime(2020),
      lastDate: DateTime.now(),
    );
    if (picked == null) return;
    setState(() {
      if (isFrom) {
        _from = picked;
        if (_to.isBefore(_from)) _to = _from;
      } else {
        _to = picked;
        if (_from.isAfter(_to)) _from = _to;
      }
    });
  }

  void _updateInsight(Map<String, List<TrendPoint>> series) {
    // Pick the first visible series that has ≥2 points
    for (var entry in series.entries) {
      final pts = entry.value;
      if (pts.length >= 2) {
        final change = pts.last.value - pts.first.value;
        final name = entry.key.toLowerCase();
        if (change.abs() < 0.5) {
          _insight = 'Your $name is steady.';
        } else if (change < 0) {
          _insight = 'Your $name has improved.';
        } else {
          _insight = 'Your $name has worsened.';
        }
        return;
      }
    }
    _insight = 'Not enough data for insight.';
  }

  void _compare(Map<String, List<TrendPoint>> series) {
    // Find best correlation pair
    double bestR = 0;
    String bestPair = '';
    final keys = series.keys.toList();
    for (var i = 0; i < keys.length; i++) {
      for (var j = i + 1; j < keys.length; j++) {
        final a = series[keys[i]]!, b = series[keys[j]]!;
        final mapB = {for (var p in b) p.date: p.value};
        final common = a.where((p) => mapB.containsKey(p.date)).toList();
        if (common.length < 2) continue;
        // compute Pearson
        final xs = common.map((p) => p.value).toList();
        final ys = common.map((p) => mapB[p.date]!).toList();
        final r = _pearson(xs, ys);
        if (r.abs() > bestR.abs()) {
          bestR = r;
          bestPair = '${keys[i]} & ${keys[j]}';
        }
      }
    }
    setState(() {
      _insight =
          bestPair.isEmpty
              ? 'No significant correlation.'
              : '$bestPair vary ${bestR > 0 ? 'together' : 'oppositely'}.';
    });
  }

  double _pearson(List<double> x, List<double> y) {
    final n = x.length;
    final mx = x.reduce((a, b) => a + b) / n;
    final my = y.reduce((a, b) => a + b) / n;
    double num = 0, dx2 = 0, dy2 = 0;
    for (var i = 0; i < n; i++) {
      final dx = x[i] - mx, dy = y[i] - my;
      num += dx * dy;
      dx2 += dx * dx;
      dy2 += dy * dy;
    }
    return dx2 * dy2 == 0 ? 0 : num / sqrt(dx2 * dy2);
  }

  @override
  Widget build(BuildContext context) {
    final logs = context.watch<LogProvider>().logs;

    // Build our series map dynamically
    final series = <String, List<TrendPoint>>{};
    for (var type in kSymptomTypes) {
      if (_show[type] == true) {
        series[type] = TrendService.instance.computeRange(
          logs,
          type,
          _from,
          _to,
        );
      }
    }

    // Recompute insight
    _updateInsight(series);

    // Determine which chips to show (only those with data)
    final available = series.keys.where((t) => series[t]!.isNotEmpty).toList();

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          children: [
            // Date pickers
            Row(
              children: [
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _pickDate(true),
                    icon: const Icon(Icons.date_range),
                    label: Text('${_from.month}/${_from.day}/${_from.year}'),
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: OutlinedButton.icon(
                    onPressed: () => _pickDate(false),
                    icon: const Icon(Icons.date_range),
                    label: Text('${_to.month}/${_to.day}/${_to.year}'),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),

            // Filter chips
            Wrap(
              spacing: 8,
              children: [
                for (var t in available)
                  FilterChip(
                    label: Text(t),
                    selected: _show[t]!,
                    onSelected: (v) => setState(() => _show[t] = v),
                  ),
              ],
            ),
            const SizedBox(height: 12),

            // Chart
            Expanded(
              child: Card(
                elevation: 2,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(8),
                  child: TrendChart(series: series, from: _from, to: _to),
                ),
              ),
            ),
            const SizedBox(height: 12),

            // Insight box
            Container(
              width: double.infinity,
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.secondary.withOpacity(.1),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Text('INSIGHT: $_insight'),
            ),
            const SizedBox(height: 12),

            // Actions
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                OutlinedButton(
                  onPressed: () => _compare(series),
                  child: const Text('COMPARE'),
                ),
                ElevatedButton(
                  onPressed:
                      () => Navigator.push(
                        context,
                        MaterialPageRoute(builder: (_) => const ReportScreen()),
                      ),
                  child: const Text('REPORT'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}


--- lib/services/database_service.dart ---
// lib/services/database_service.dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

class DatabaseService {
  // Singleton boilerplate
  DatabaseService._internal();
  static final DatabaseService instance = DatabaseService._internal();
  factory DatabaseService() => instance;

  late final Database _db;

  Future<void> init() async {
    _db = await openDatabase(
      join(await getDatabasesPath(), 'symptomtracker.db'),
      version: 1,
      onCreate: (db, _) async {
        await db.execute('''
          CREATE TABLE logs(
            id INTEGER PRIMARY KEY,
            date INTEGER UNIQUE,
            data TEXT
          )
        ''');
        await db.execute('''
          CREATE TABLE meds(
            id INTEGER PRIMARY KEY,
            name TEXT,
            dosage TEXT,
            timesPerDay INTEGER,
            takenToday INTEGER
          )
        ''');
      },
    );
  }

  Database get db => _db;
}


--- lib/services/notification_service.dart ---
// lib/services/notification_service.dart
import 'package:flutter/material.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:timezone/data/latest.dart' as tz;
import 'package:timezone/timezone.dart' as tz;

class NotificationService {
  NotificationService._internal();
  static final NotificationService instance = NotificationService._internal();
  factory NotificationService() => instance;

  final FlutterLocalNotificationsPlugin _plugin =
      FlutterLocalNotificationsPlugin();

  Future<void> init() async {
    tz.initializeTimeZones();
    const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
    await _plugin.initialize(
      const InitializationSettings(android: androidInit),
    );
  }

  /// Schedule a daily reminder at the given [TimeOfDay].
  Future<void> scheduleDaily(TimeOfDay tod) async {
    final now = tz.TZDateTime.now(tz.local);
    var scheduled = tz.TZDateTime(
      tz.local,
      now.year,
      now.month,
      now.day,
      tod.hour,
      tod.minute,
    );
    if (scheduled.isBefore(now)) {
      scheduled = scheduled.add(const Duration(days: 1));
    }

    await _plugin.zonedSchedule(
      0,
      'Log your symptoms',
      'Tap to open Symptom Tracker',
      scheduled,
      const NotificationDetails(
        android: AndroidNotificationDetails(
          'daily_reminder',
          'Daily Reminder',
          importance: Importance.high,
        ),
      ),
      // New required parameter replacing androidAllowWhileIdle:
      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
      // Removed the deprecated uiLocalNotificationDateInterpretation entirely
      // and now match only on the time component:
      matchDateTimeComponents: DateTimeComponents.time,
    );
  }
}


--- lib/services/report_service.dart ---
// lib/services/report_service.dart
import 'dart:io';
import 'package:pdf/widgets.dart' as pw;
import 'package:pdf/pdf.dart'; // ← NEW
import 'package:path_provider/path_provider.dart';
import '../models/log_entry.dart';
import '../models/medication.dart';

class ReportService {
  ReportService._internal();
  static final ReportService _instance = ReportService._internal();
  factory ReportService() => _instance;

  Future<File> generate(
    List<LogEntry> logs,
    List<Medication> meds,
    DateTime from,
    DateTime to,
    String questions,
  ) async {
    final doc = pw.Document();

    doc.addPage(
      pw.MultiPage(
        build:
            (ctx) => [
              // Colourful header
              pw.Container(
                color: PdfColor.fromInt(0xff1E88E5), // ← use PdfColor.fromInt
                padding: const pw.EdgeInsets.all(12),
                child: pw.Center(
                  child: pw.Text(
                    'Symptom Tracker Report',
                    style: pw.TextStyle(
                      color: PdfColors.white, // ← use PdfColors.white
                      fontSize: 20,
                      fontWeight: pw.FontWeight.bold,
                    ),
                  ),
                ),
              ),
              pw.SizedBox(height: 12),
              pw.Paragraph(
                text:
                    'Period: ${from.month}/${from.day}/${from.year} — '
                    '${to.month}/${to.day}/${to.year}',
              ),
              pw.SizedBox(height: 12),

              pw.Header(text: 'Symptoms'),
              _symptomsTable(logs),
              pw.SizedBox(height: 12),

              pw.Header(text: 'Medications'),
              _medsTable(meds),
              if (questions.trim().isNotEmpty) ...[
                pw.SizedBox(height: 12),
                pw.Header(text: 'Questions'),
                pw.Bullet(text: questions),
              ],
            ],
      ),
    );

    final dir = await getTemporaryDirectory();
    final file = File('${dir.path}/symptom_report.pdf');
    await file.writeAsBytes(await doc.save());
    return file;
  }

  pw.Widget _symptomsTable(List<LogEntry> logs) {
    return pw.Table.fromTextArray(
      headers: ['Date', 'Type', 'Location', 'Severity'],
      data: [
        for (var l in logs)
          for (var s in l.symptoms)
            [
              '${l.date.month}/${l.date.day}/${l.date.year}',
              s.type,
              s.location.isEmpty ? '-' : s.location,
              s.severity.toString(),
            ],
      ],
    );
  }

  pw.Widget _medsTable(List<Medication> meds) {
    return pw.Table.fromTextArray(
      headers: ['Name', 'Dosage', 'Taken Today'],
      data: [
        for (var m in meds) [m.name, m.dosage, m.takenToday ? 'Yes' : 'No'],
      ],
    );
  }
}


--- lib/services/trend_service.dart ---
// lib/services/trend_service.dart
import '../models/log_entry.dart';
import '../models/trend_point.dart';

/// A service to compute time-series TrendPoint lists for any symptom type.
class TrendService {
  TrendService._internal();
  static final TrendService instance = TrendService._internal();
  factory TrendService() => instance;

  /// Returns one TrendPoint per calendar day between [from] and [to]
  /// by averaging all severities of [type] logged on that day.
  List<TrendPoint> computeRange(
    List<LogEntry> logs,
    String type,
    DateTime from,
    DateTime to,
  ) {
    // Group severities by date
    final Map<DateTime, List<int>> accum = {};
    for (var log in logs) {
      if (log.date.isBefore(from) || log.date.isAfter(to)) continue;
      // Extract severities for this type
      final sev = log.symptoms
          .where((s) => s.type == type)
          .map((s) => s.severity)
          .toList();
      if (sev.isEmpty) continue;
      // Normalize to midnight
      final key = DateTime(log.date.year, log.date.month, log.date.day);
      accum.putIfAbsent(key, () => []).addAll(sev);
    }

    // Build sorted TrendPoint list
    final pts = accum.entries
        .map((e) {
          final avg = e.value.reduce((a, b) => a + b) / e.value.length;
          return TrendPoint(date: e.key, value: avg);
        })
        .toList()
      ..sort((a, b) => a.date.compareTo(b.date));

    return pts;
  }
}


--- lib/themes/app_theme.dart ---
// lib/themes/app_theme.dart
import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData build(bool dark) {
    final base   = dark ? ThemeData.dark() : ThemeData.light();
    final colors = dark
        ? const ColorScheme.dark(
            primary: Color(0xFF0091EA), // blue-accent
            secondary: Color(0xFFFFA726), // orange
          )
        : const ColorScheme.light(
            primary: Color(0xFF0066CC), // blue
            secondary: Color(0xFFF57C00), // orange
          );

    return base.copyWith(
      colorScheme: colors,
      scaffoldBackgroundColor:
          dark ? const Color(0xFF121212) : const Color(0xFFF7F9FC),
      appBarTheme: AppBarTheme(
        backgroundColor: colors.primary,
        foregroundColor: Colors.white,
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: dark
            ? const Color(0xFF1D1D1D)
            : Colors.white,
        selectedItemColor: colors.primary,
        unselectedItemColor: Colors.grey.shade500,
        showUnselectedLabels: true,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: colors.primary,
          foregroundColor: Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: dark ? const Color(0xFF1E1E1E) : Colors.white,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
        ),
      ),
      visualDensity: VisualDensity.adaptivePlatformDensity,
    );
  }
}


--- lib/utils/constants.dart ---
// lib/utils/constants.dart
const kSymptomTypes = ['Pain','Fatigue','Nausea','Sleep quality','Mood'];
const kBodyParts = [
  'Head','Chest','Abdomen','Left Arm','Right Arm','Left Leg','Right Leg'
];


--- lib/widgets/body_map.dart ---
// lib/widgets/body_map.dart
import 'package:flutter/material.dart';
import '../utils/constants.dart';

class BodyMap extends StatefulWidget {
  final Set<String> selected;
  final ValueChanged<Set<String>> onChanged;
  const BodyMap({
    required this.selected,
    required this.onChanged,
    super.key,
  });
  @override
  State<BodyMap> createState() => _BodyMapState();
}

class _BodyMapState extends State<BodyMap> {
  late Set<String> sel;
  @override
  void initState() {
    super.initState();
    sel = widget.selected;
  }
  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 8,
      children: kBodyParts.map((part){
        final active = sel.contains(part);
        return FilterChip(
          label: Text(part),
          selected: active,
          onSelected: (v){
            setState((){
              v ? sel.add(part) : sel.remove(part);
              widget.onChanged(sel);
            });
          },
        );
      }).toList(),
    );
  }
}


--- lib/widgets/calendar_strip.dart ---
// lib/widgets/calendar_strip.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../providers/log_provider.dart';

class CalendarStrip extends StatefulWidget {
  final ValueChanged<DateTime> onDateSelected;
  const CalendarStrip({required this.onDateSelected, super.key});
  @override
  State<CalendarStrip> createState() => _CalendarStripState();
}

class _CalendarStripState extends State<CalendarStrip> {
  DateTime _sel = DateTime.now();

  @override
  Widget build(BuildContext context) {
    final logs = context.watch<LogProvider>().logs;
    return SizedBox(
      height: 80,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: 14,
        itemBuilder: (_, i) {
          final d = DateTime.now().subtract(Duration(days: 13 - i));
          final has = logs.any((l) =>
              l.date.year==d.year &&
              l.date.month==d.month &&
              l.date.day==d.day);
          final sel = d.year==_sel.year&&d.month==_sel.month&&d.day==_sel.day;
          return GestureDetector(
            onTap: (){
              setState(()=>_sel=d);
              widget.onDateSelected(d);
            },
            child: Container(
              width:60,
              margin: const EdgeInsets.all(4),
              decoration: BoxDecoration(
                color: sel?Theme.of(context).colorScheme.primary:null,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children:[
                  Text(DateFormat('E').format(d),
                      style: TextStyle(color: sel?Colors.white:null)),
                  Text(DateFormat('d').format(d),
                      style: TextStyle(
                          fontSize:18,
                          color: sel?Colors.white:null)),
                  if(has)
                    Icon(Icons.circle,
                        size:8,
                        color: sel?Colors.white:Theme.of(context).colorScheme.secondary)
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}


--- lib/widgets/med_list_item.dart ---
// lib/widgets/med_list_item.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/medication.dart';
import '../providers/med_provider.dart';

class MedListItem extends StatelessWidget {
  final Medication med;
  final VoidCallback onTap;
  const MedListItem({
    required this.med,
    required this.onTap,
    super.key,
  });
  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(med.name),
      subtitle: Text('${med.dosage}, ${med.timesPerDay}×/day'),
      trailing: Checkbox(
        value: med.takenToday,
        onChanged: (_) =>
            context.read<MedProvider>().toggleTaken(med),
      ),
      onTap: onTap,
    );
  }
}


--- lib/widgets/severity_slider.dart ---
// lib/widgets/severity_slider.dart
import 'package:flutter/material.dart';
class SeveritySlider extends StatelessWidget {
  final int value;
  final ValueChanged<int> onChanged;
  const SeveritySlider({
    required this.value,
    required this.onChanged,
    super.key,
  });
  @override
  Widget build(BuildContext context) {
    return Row(
      children:[
        const Text('Severity'),
        Expanded(
          child: Slider(
            value: value.toDouble(),
            min:0,
            max:10,
            divisions:10,
            label:'$value',
            onChanged:(v)=>onChanged(v.toInt()),
          ),
        ),
      ],
    );
  }
}


--- lib/widgets/trend_chart.dart ---
// lib/widgets/trend_chart.dart
import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import '../models/trend_point.dart';

/// Multi‐line time‐series chart with even spacing and clean MM/DD bottom labels.
class TrendChart extends StatelessWidget {
  final Map<String, List<TrendPoint>> series;
  final DateTime from, to;

  const TrendChart({
    required this.series,
    required this.from,
    required this.to,
    super.key,
  });

  static const _palette = [
    Color(0xff1E88E5),
    Color(0xffF4511E),
    Color(0xff43A047),
    Color(0xff8E24AA),
    Color(0xffFB8C00),
    Color(0xff3949AB),
  ];

  @override
  Widget build(BuildContext context) {
    // Filter out any series with no points in-range
    final visible =
        series.entries
            .where(
              (e) => e.value.any(
                (p) => !p.date.isBefore(from) && !p.date.isAfter(to),
              ),
            )
            .toList();
    if (visible.isEmpty) {
      return const Center(child: Text('No data in this range'));
    }

    // Total days between from→to
    final totalDays = to.difference(from).inDays;
    // Build one LineChartBarData per visible symptom
    final lines = <LineChartBarData>[];
    for (var i = 0; i < visible.length; i++) {
      final pts =
          visible[i].value
              .where((p) => !p.date.isBefore(from) && !p.date.isAfter(to))
              .map(
                (p) =>
                    FlSpot(p.date.difference(from).inDays.toDouble(), p.value),
              )
              .toList()
            ..sort((a, b) => a.x.compareTo(b.x));
      if (pts.isEmpty) continue;
      lines.add(
        LineChartBarData(
          spots: pts,
          isCurved: true,
          color: _palette[i % _palette.length],
          barWidth: 2.5,
          dotData: const FlDotData(show: true),
        ),
      );
    }

    // Axis label builders
    Widget bottomTitle(double v, TitleMeta _) {
      final day = v.round();
      final dt = from.add(Duration(days: day));
      return Padding(
        padding: const EdgeInsets.only(top: 4),
        child: Text(
          '${dt.month}/${dt.day}',
          style: const TextStyle(fontSize: 10),
        ),
      );
    }

    // Determine bottom‐axis interval (approx four segments)
    final rawInterval = totalDays / 4;
    final bottomInterval = rawInterval < 1 ? 1.0 : rawInterval.ceilToDouble();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Legend
        Wrap(
          spacing: 12,
          runSpacing: 4,
          children: [
            for (var i = 0; i < visible.length; i++)
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: 12,
                    height: 4,
                    color: _palette[i % _palette.length],
                  ),
                  const SizedBox(width: 4),
                  Text(visible[i].key, style: const TextStyle(fontSize: 12)),
                ],
              ),
          ],
        ),
        const SizedBox(height: 6),
        // Chart
        Expanded(
          child: LineChart(
            LineChartData(
              minX: 0,
              maxX: totalDays.toDouble(),
              minY: 0,
              maxY: 10,
              gridData: const FlGridData(
                show: true,
                horizontalInterval: 2,
                drawVerticalLine: false,
              ),
              borderData: FlBorderData(
                show: true,
                border: const Border(bottom: BorderSide(), left: BorderSide()),
              ),
              titlesData: FlTitlesData(
                // Bottom: only MM/DD
                bottomTitles: AxisTitles(
                  sideTitles: SideTitles(
                    showTitles: true,
                    interval: bottomInterval,
                    reservedSize: 32, // give room for labels
                    getTitlesWidget: bottomTitle,
                  ),
                ),
                // Left: 0–10
                leftTitles: AxisTitles(
                  sideTitles: SideTitles(
                    showTitles: true,
                    interval: 2,
                    reservedSize: 40,
                    getTitlesWidget:
                        (v, _) => Text(
                          v.toInt().toString(),
                          style: const TextStyle(fontSize: 10),
                        ),
                  ),
                ),
                // Hide top & right
                topTitles: AxisTitles(
                  sideTitles: SideTitles(showTitles: false),
                ),
                rightTitles: AxisTitles(
                  sideTitles: SideTitles(showTitles: false),
                ),
              ),
              lineBarsData: lines,
            ),
          ),
        ),
      ],
    );
  }
}


--- lib/main.dart ---
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'services/database_service.dart';
import 'services/notification_service.dart';
import 'providers/settings_provider.dart';
import 'providers/log_provider.dart';
import 'providers/med_provider.dart';
import 'themes/app_theme.dart';
import 'screens/home_screen.dart';
import 'screens/log_symptom_screen.dart';
import 'screens/med_edit_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await DatabaseService().init();
  await NotificationService().init();
  runApp(const SymptomTrackerApp());
}

class SymptomTrackerApp extends StatelessWidget {
  const SymptomTrackerApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => SettingsProvider()),
        ChangeNotifierProvider(create: (_) => LogProvider()..load()),
        ChangeNotifierProvider(create: (_) => MedProvider()..load()),
      ],
      child: Consumer<SettingsProvider>(
        builder:
            (_, settings, __) => MaterialApp(
              debugShowCheckedModeBanner: false,
              title: 'Symptom Tracker',
              theme: AppTheme.build(settings.darkMode),
              initialRoute: '/',
              routes: {
                '/': (_) => const HomeScreen(),
                '/log': (_) => const LogSymptomScreen(),
                '/med_edit': (_) => const MedEditScreen(),
              },
            ),
      ),
    );
  }
}


